Применение DSM-платформы QReal при
разработке среды программирования роботов
QReal:Robots
В настоящее время в российских школах для препода-
вания информатики активно внедряются робототехнические
конструкторы Lego Mindstorms NXT. Для программирова-
ния таких роботов обычно используются визуальные языки,
но сред разработки, полностью удовлетворяющих учителей и
учеников, сейчас не существует. В данной работе представлен
опыт разработки таких средств с помощью DSM-платформы
QReal. В статье даётся краткий обзор архитектуры системы
QReal, описывается созданный язык программирования ро-
ботов и роль DSM-средства QReal в процессе его создания.
Делаются выводы о том, насколько эффективным оказался
DSM-подход для решения поставленной задачи.
Ключевые слова: Визуальное моделирование, модельно-
ориентированная разработка, предметно-ориентированное моделирова-
ние, DSM-подход, программирование роботов, школьная информатика
Введение
Сейчас в школах для преподавания информатики активно внед-
ряются робототехнические конструкторы. Детям проще создавать
мый объект исполняет описанные в программе команды. Самым по-
пулярным на данный момент робототехническим набором является
конструктор Lego Mindstorms NXT [23] (далее— конструктор Lego).
Он позволяет собирать из блоков управления, моторов и различ-
ных датчиков (датчики касания, расстояния, света и др.) неслож-
ные устройства, которые могут исполнять команды, посланные с
компьютера по интерфейсу Bluetooth, или исполнять программу,
загруженную на блок управления.
Для программирования конструктора Lego существуют
несколько сред программирования, например, NXT-G и Robolab
[29]. Однако эти среды обладают рядом недостатков, затрудня-
ющих их использование—отсутствие полного перевода на русский
язык, неудобный пользовательский интерфейс, недостаточная
функциональность, высокая стоимость. Таким образом, существу-
ет потребность в разработке системы визуального программиро-
вания для конструкторов Lego, специально предназначенной для
применения в российских школах.
На кафедре системного программирования Санкт-
Петербургского государственного университета уже несколько
десятилетий занимаются исследованиями в области визуаль-
ных языков, создания CASE-систем1 и их применением в
области разработки систем реального времени и встроенных
систем [3–6, 8, 8–10, 13, 14, 18, 33]. В частности, с 2007 года су-
ществует и активно развивается проект QReal [12]. В рамках
этого проекта разрабатываются средства поддержки визуальных
предметно-ориентированных языков (Domain-Specific Modelling,
DSM-подход). Поскольку разработка визуального языка програм-
мирования роботов и соответствующих программных средств
поддержки является интересной областью для использования
предметно-ориентированного подхода, было решено применить
результаты проекта QReal для решения этой задачи.
С научной точки зрения программирование роботов является
интересной предметной областью для апробации DSM-подхода. С
одной стороны, использование визуальных языков программиро-
вания широко распространено среди людей, занимающихся робо-
тотехникой, поэтому здесь можно рассчитывать на содержатель-
ное сравнение с существующими решениями и обратную связь от
пользователей, уже знакомых с различными визуальными среда-
ми. С другой стороны, программирование роботов— узкая предмет-
ная область, поэтому можно получить заметное преимущество от
специализированного языка. Вместе с тем эта область достаточно
содержательна, поэтому такой язык остаётся нетривиальным. Ти-
пичные программы для роботов состоят из элементарных команд,
таких как «включить моторы», «ожидать такое-то показание сен-
сора» и т. д., и управляющих конструкций, таких как условные опе-
раторы и циклы. На языке общего назначения такие команды были
бы вызовами программного интерфейса (Application Programming
Interface, далее— API), операционной системы или библиотек робо-
та и требовали бы для себя различных вспомогательных конструк-
ций, таких как операторы включения и объявления переменных, а
на специализированном языке каждая такая команда представля-
ется одним блоком, для использования которого достаточно просто
разместить его на диаграмме. Это существенно снижает требования
к знаниям программиста и вероятность ошибки в программе— на-
пример, невозможно ошибиться при указании имени вызываемой
функции. Вместе с тем многие языковые конструкции, типичные
для императивного программирования, такие как ветвления и цик-
лы, будут присутствовать и в этом языке, так что если удастся
подобрать удобное графическое представление для программ для
роботов, можно будет обобщить полученный результат на другие
задачи, хорошо выражаемые в императивных терминах.
В этой статье описано, с какими трудностями пришлось столк-
нуться в ходе разработки визуальной среды программирования
конструктора Lego, чем помогDSM- инструментарий, а в чём он
не смогп омочь. Изложенные в статье результаты могут быть инте-
ресны тем, что разрабатываемую с помощью DSM-инструментария
систему удалось довести до состояния, в котором её смогли успеш-
но использовать люди, занимающиеся робототехникой и далёкие от
программирования, в том числе и ученики 5–6 классов.
1. Средства визуального программирования роботов
Cуществует довольно много сред программирования роботов Lego,
в том числе и визуальных. Наиболее популярными на данный мо-
мент являются среды NXT-G, Robolab [30], Microsoft Robotics Developer
Studio [25].
Среда NXT-G поставляется в комплекте с конструктором Lego
Mindstorms NXT, базируется на системе LabView (системе, предна-
значенной для моделирования и обработки данных научных экспе-
риментов) и имеет модель вычислений, ориентированную на дан-
ные. Язык NXT-G состоит из блоков, блоки имеют входы и вы-
ходы, блок начинает выполнение, когда на всех его входах есть
готовые данные. Такой подход отличается от принятого в класси-
ческих блок-схемах, однако распространён в средствах, используе-
мых учёными и инженерами, а также в автоматном программиро-
вании [16,17]. NXT-G имеет ряд существенных недостатков, напри-
мер, слабую поддержку математических выражений: каждая эле-
ментарная операция представляется отдельным блоком, что фак-
тически требует от пользователя рисовать дерево разбора ариф-
метического выражения. Таким образом, даже такая несложная и
широко используемая конструкция, как пропорциональный регуля-
тор, на NXT-G будет выглядеть очень объёмно и сложно.
Среда Robolab [30] так же, как и NXT-G, базируется на Lab-
View и использует ту же модель вычислений, однако позволяет пи-
сать математические выражения текстом. Поэтому среда Robolab
гораздо шире распространена среди людей, серьёзно увлекающихся
робототехникой. Интересная особенность этой среды заключается
в том, что она специально создавалась для образовательных це-
лей. Robolab поддерживает несколько уровней использования. На
самом первом уровне пользователю предоставляется готовый шаб-
лон программы, где он может только выбрать, с какого сенсора
считать данные и на какой мотор послать команду. А на последнем
уровне пользователь может произвольным образом комбинировать
более 400 блоков языка, используя ветвления, циклы, параллельное
исполнение, подпрограммы и т. д. Таким образом, система полез-
на как дошкольникам, так и старшеклассникам. Пользовательский
интерфейс Robolab выглядит устаревшим, а сама среда довольно
дорога, поэтому у многих школьных учителей есть желание отка-
заться от Robolab в пользу чего-нибудь более современного, но пока
у Robolab не существует серьёзных конкурентов.
Среда Microsoft Robotics Developer Studio (MRDS) [25] гораздо
мощнее и сложнее рассмотренных выше продуктов. Она создава-
лась как средство визуального программирования сложных мно-
гопоточных приложений с реактивным поведением, которые могут
применяться не только в робототехнике, но и во многих других об-
ластях, например, для программирования серверного ПО для круп-
ных Web-сайтов. Язык визуального программирования VPL (Visual
Programming Language), используемый в MRDS, по сути, ви-
зуализирует связи по данным между отдельными параллельно ис-
полняемыми компонентами (Web-сервисами), из которых состоит
программа. Такой подход требует больших вычислительных ресур-
сов (больше, чем среды, описанные выше), поэтому MRDS может
управлять роботом Lego только дистанционно, исполняя програм-
му на компьютере. Сама среда ориентирована на более дорогие ро-
боты, имеющие в своём составе полноценный компьютер (напри-
мер, в документации к MRDS описана «стандартная модель» робо-
та— трёхколёсная платформа с установленным на ней ноутбуком,
сенсором Microsoft Kinect, инфракрасными датчиками расстояния
и сонаром). Среда ориентирована на студентов и профессиональ-
ных программистов, начинающим знакомиться с робототехникой
использовать её сложно. Кроме того, применяемая модель вычис-
лений слишком специфична, чтобы быть полезной в качестве ил-
люстративного материала при преподавании робототехники и про-
граммирования.
Таким образом, можно сделать вывод о том, что существующие
среды, кроме Robolab, слабо подходят для преподавания в россий-
ских школах. Среда Robolab также имеет ряд существенных недо-
статков. Таким образом, есть потребность в создании свободно рас-
пространяемой среды программирования, схожей по функциональ-
ности с Robolab, но обладающей рядом дополнительных возмож-
ностей, таких как средства отладки, генерация кода, полноценная
русификация.
2. Предметно-ориентированное моделирование
Предметно-ориентированное визуальное моделирование—перспек-
тивный и развивающийся сегодня подход к разработке программ-
ного обеспечения. Его суть заключается в том, что прикладная
задача решается не с помощью языка общего назначения, такого
как C++, Java, C#, UML, а с помощью узкоспециализированно-
го визуального языка, специально созданного для решения задач
в данной предметной области или даже для решения одной зада-
чи. Узкая направленность языка позволяет эффективно создавать
на нём законченные программы, не требующие модификаций на
текстовых языках программирования. Специализированный язык
близок к предметной области, и это позволяет использовать его да-
же людям, не владеющим программированием.
Для создания предметно-ориентированного решения требуется
небольшой коллектив высококвалифицированных программистов и
аналитиков. По окончании разработки этим решением может поль-
зоваться большое количество обычных программистов либо экспер-
тов предметной области, что обходится дешевле, чем разработка си-
стемы традиционными средствами. Кроме визуальных, существу-
ют хорошо известные текстовые предметно-ориентированные язы-
ки, такие как SQL, AWK, а также языки описания грамматик в
конструкторах компиляторов. Исследования [20, 21, 31] сообщают о
росте производительности труда программиста в 3–10 раз при ис-
пользовании предметно-ориентированных языков по сравнению с
программированием на текстовых языках общего назначения.
Разумеется, создавать специальный визуальный язык и разра-
батывать для него инструментальные средства «вручную» было
бы весьма непросто. Создание хорошей CASE-системы «с нуля»
под силу только компаниям, которые на этом специализируются,
и оправдано только в том случае, если эта CASE-система будет
продаваться как коробочный продукт для массового покупателя,
что противоречит самой идее предметно-ориентированного модели-
рования. Поэтому активно развиваются специальные инструменты
для быстрого создания визуальных языков и средств их инструмен-
тальной поддержки, так называемые DSM-платформы [10]. Любая
такая платформа позволяет в том или ином виде описать синтаксис
визуального языка и автоматически (или полуавтоматически) со-
здать для него визуальный редактор. Некоторые DSM-платформы
также позволяют задать для визуального языка правила генерации
в текстовый целевой язык, описать набор доступных для языка
инструментов и т. д. Наиболее зрелыми на данный момент DSM-
платформами являются Eclipse Graphical Modelling Project [11,22],
MetaEdit+ [24], Visual Studio Visualization and Modeling SDK [32],
Microsoft Visio [26].
Платформа Graphical Modelling Project (GMP) —это набор про-
ектов в области визуального моделирования. Самыми зрелыми яв-
ляются продукты Eclipse Modeling Framework (библиотека для ра-
боты с метамоделями/моделями с помощью API, а также в тек-
стовом виде) и Graphical Editing Framework (библиотеки для ре-
дакторов графов)2. GMP является мощной платформой и предо-
ставляет возможность создавать отчуждаемые визуальные редак-
торы и генераторы кода, позволяя задавать метамодель языка в
том числе и с помощью стандарта обмена метамоделями XMI [27],
имеет открытый исходный код и распространяется свободно, явля-
ясь де-факто стандартом для осуществления научных исследова-
ний. С её помощью можно легко получить простой графический
редактор для несложного визуального языка, но когда возникают
более-менее нестандартные требования, то использование техноло-
гии оказывается очень сложным3.
DSM-платформа MetaEdit+ является наиболее зрелой на дан-
ный момент и активно используется в промышленном програм-
мировании. Она имеет свой метаязык и графический редактор
для описания абстрактного синтаксиса визуального языка, а так-
же редактор формы элементов для задания конкретного синтак-
сиса и текстовый язык описания правил генерации целевого кода.
MetaEdit+ позволяет создавать отдельно работающие редакторы.
Её основными недостатками являются высокая цена и то, что ис-
ходные коды этой системы закрыты.
Visual Studio Visualization and Modeling SDK (бывший Microsoft
DSL Tools) позволяет создавать визуальные редакторы, встраива-
емые в среду Microsoft Visual Studio 2010. На нём довольно удобно
описывать простые визуальные языки, однако если требуется что-
то нестандартное (например, нестандартные фигуры элементов),
то требуется ручное кодирование на языке C#. Распространяется
продукт бесплатно, но может применяться только в составе сре-
ды Visual Studio, стоимость которой довольно велика. Кроме того,
получающиеся в итоге графические редакторы также неразрывно
связаны с Visual Studio.
Среда Microsoft Visio позиционируется разработчиками скорее
как векторный графический редактор, чем как DSM-платформа,
однако содержит средства описания новых фигур, полноценный
API и средства интеграции с Visual Studio, что даёт возможность
использовать её в качестве легковесной DSM-платформы. Исполь-
зование её в таком качестве оказалось удобным, в том числе и в
коммерческих проектах [8]. Однако Visio не обладает всей необходи-
мой для DSM-платформы функциональностью— нет полноценных
средств описания метамодели, недостаточно функциональный про-
граммный интерфейс, затрудняющий работу с диаграммами сто-
ронних инструментов, сложности с созданием нетривиальных фи-
гур, нет разделения на модель и представления (vsd-файлы хранят
диаграммную и модельную информацию вместе, что сильно затруд-
няет программную обработку моделей в Visio).
3. Cистема QReal
Кроме упомянутых выше известных и зрелых DSM-платформ, су-
ществует и некоторое количество академических разработок. Одна
из таких разработок—платформа QReal [12], созданная на кафед-
ре системного программирования Санкт-Петербургского государ-
ственного университета. QReal—это метаCASE-система, разраба-
тываемая как проект с открытым исходным кодом [2]. На данный
момент система QReal обладает следующими возможностями.
• Средства для задания метамодели визуального языка в спе-
циальном XML-формате либо в графической форме. Со-
ответствующий редактор сам реализован как предметно-
ориентированный язык, существует его метамодель в ви-
де XML-описания, и для него применимы все возможности
QReal, используемые при разработке других визуальных язы-
ков.
• Средства для задания формы фигур визуального языка с по-
мощью встроенного графического редактора форм, представ-
ляющего собой простой векторный графический редактор с
поддержкой возможности отображать значения логических
свойств элемента прямо на фигуре. В качестве альтернативы
есть возможность задавать форму фигуры непосредственно
в XML-файле метамодели в формате, похожем на стандарт
векторной графики SVG.
• Средства автоматической генерации кода редактора по ме-
тамодели и описаниям форм фигур. Редактор генерирует-
ся как подключаемый модуль на языке C++ и подгружает-
ся в среду QReal сразу по окончании генерации и сборки.
Имея собранный редактор, метаредактор можно отключить
и использовать QReal как независимый редактор предметно-
ориентированного языка.
• Репозиторий, в котором хранятся все данные создаваемых
пользователем моделей. Этими данными могут пользоваться
как подключаемые модули QReal, так и сторонние приложе-
ния, которые могут подключать репозиторий как динамиче-
ски загружаемую библиотеку.
• Программный интерфейс для подключаемых модулей-
инструментов, открывающий доступ как к репозиторию,
так и к общей функциональности системы, такой как вывод
ошибок пользователю и подсветка элементов на диаграмме.
Интерфейс позволяет создавать инструменты «вручную» на
C++ и реализовывать с их помощью генераторы кода, сред-
ства возвратного проектирования, интерпретаторы моделей,
различные валидаторы и т. д.
4. Визуальный язык QReal:Robots
Визуальный язык программирования роботов, используемый в
QReal:Robots, основывается на абстракции потока управления.
Язык состоит из блоков, представляющих элементарные команды
роботу, такие как «включить моторы на указанных портах с ука-
занной мощностью на указанное количество оборотов», и связей,
показывающих передачу управления от одного блока к другому.
В момент выполнения программы существует один или несколько
маркеров выполнения. Блок, получивший маркер, выполняет свои
команды и отдаёт маркер блоку, с которым он связан соединитель-
ной линией. Пример программы приведён на рис. .
Все блоки языка делятся на несколько крупных смысловых
групп, которые могут быть отдельно свёрнуты/развёрнуты в па-
литре. В языке присутствуют следующие блоки.
• Алгоритмы — блоки для организации диаграмм и управления
вычислительным процессом.
– Диаграмма поведения робота—позволяет создавать но-
вые диаграммы. В каждый конкретный момент времени
может быть выполнена или сгенерирована только одна
диаграмма, но проект может содержать несколько диа-
грамм, между которыми можно переключаться.
– Линия соединения— задаёт последовательность переда-
чи управления между блоками.
– Параллельные задачи— позволяют разделить поток
управления на несколько параллельных потоков, кото-
рые будут исполняться независимо. Выглядит как блок,
из которого выходит несколько соединительных линий,
который при получении маркера управления создаёт
несколько маркеров (по одному для каждой соединитель-
ной линии) и отправляет их каждому соединённому с ним
блоку. После разделения задачи независимы.
– Условие— оператор, проверяющий заданное логическое
условие и, в зависимости от исхода проверки, передаю-
щий маркер управления на одну из двух исходящих со-
единительных линий. Поскольку в QReal, в отличие от
LabView, у блока нет понятия «порт» в том смысле, что
все исходящие линии равнозначны, одна из них должна
быть помечена условием, по которому выполняется пере-
ход, а вторая должна быть не помечена. По непомеченной
связи управление передаётся в том случае, если условие
не выполнено.
– Цикл —блок для задания аналога цикла for в текстовых
языках. Блок должен иметь две исходящие связи, по од-
ной из которых передаётся управление до тех пор, пока
выполняется цикл. Когда цикл заканчивается, то управ-
ление передаётся по второй связи. Количество итераций
задаётся как параметр блока.
• Действия — команды роботу.
– Гудок —команда роботу издать звук.
– Играть звук—команда роботу издать звук заданной ча-
стоты и громкости. Отличается от блока «Гудок» суще-
ственно большими возможностями в настройке.
– Моторы вперёд—команда роботу включить моторы на
заданных портах с заданной мощностью на заданное ко-
личество оборотов. Если число оборотов указано как 0,
моторы будут работать неограниченно.
– Моторы назад— команда роботу включить моторы в ре-
жиме движения назад с параметрами, аналогичными па-
раметрам блока «Моторы вперёд».
– Моторы стоп— команда роботу выключить моторы.
– Функция — блок для записи произвольного математиче-
ского выражения или кода на С.
• Инициализация —блоки, отвечающие за инициализацию ро-
бота и начало работы программы.
– Блок инициализации позволяет задать начало програм-
мы, а также указать расположение сенсоров на портах.
– Конец—блок, обозначающий конец программы и отклю-
чение моторов и сенсоров робота.
– Начало—блок, аналогично блоку инициализации обо-
значающий начало программы, но без параметров.
– Сбросить показания энкодеров—блок, обнуляющий зна-
чения счётчиков оборотов моторов.
• Ожидания — блок, передающий управление дальше только
при наступлении какого-либо события.
– Ждать интенсивность цвета—блок, продолжающий вы-
полнение программы только в том случае, если значение,
возвращаемое сенсором цвета на заданном порту, будет
больше или меньше заданного значения.
– Ждать свет— блок, продолжающий выполнение про-
граммы, если значение, возвращаемое сенсором освещён-
ности на заданном порту, будет больше или меньше за-
данного значения.
– Ждать сенсор касания— выполнение программы продол-
жается при срабатывании сенсора касания на заданном
порту.
– Ждать сонар— выполнение программы продолжается,
если значение, которое вернул ультразвуковой сенсор
расстояния, больше или меньше указанного значения.
– Ждать цвет— выполнение программы будет продолже-
но, если сенсор цвета обнаружит заданный цвет.
– Ждать энкодер—выполнение продолжится, если значе-
ние счётчика оборотов на указанном порту будет больше
заданного.
– Таймер —выполнение продолжится по истечении указан-
ного промежутка времени (в миллисекундах).
Язык позволяет везде, где можно, задавать численные парамет-
ры, использовать математические выражения, включающие в се-
бя арифметические действия, тригонометрические функции и пе-
ременные. Кроме того, имеется специальный блок «Функция», ис-
пользуемый для работы с математическими выражениями. В вы-
ражениях можно использовать текущие показания с помощью так
называемых сенсорных переменных —предопределённых перемен-
ных с именами Сенсор1, Сенсор2 и т. д., значения которых обнов-
ляются в соответствии с показаниями сенсоров. Пример програм-
мы, использующей математические выражения и сенсорные пере-
менные, приведён на рис. . На этом рисунке показана реализация
алгоритма движения робота вдоль чёрной линии на полу по пока-
заниям двух датчиков освещённости на основе пропорционально-
дифференциального регулятора (подробнее см., например, в [15]).
Язык QReal:Robots можно рассматривать как типичный при-
мер визуального предметно-ориентированного языка. Важно, что
программа на визуальном языке понятна даже такому пользовате-
лю, который впервые видит этот язык, но имеет некоторый опыт в
программировании роботов. Для этого используется такой приём,
как отображение блоков языка в виде картинок, понятных людям,
которые ориентируются в предметной области (описанный, напри-
мер, в [19]). Так блоки, управляющие моторами, изображаются в
виде моторов из конструктора Lego NXT, и все, кто хоть немно-
го знаком с этим конструктором, по внешнему виду блока смогут
понять его предназначение. Кроме того, оказалось важным, что пе-
редача управления между блоками изображается стрелками—это
делает программу ещё более наглядной.
5. Инструментальные средства QReal:Robots
С помощью QReal оказалось легко создать визуальный язык, но
инструментальные средства для него необходимо создавать вруч-
ную—управление реальным роботом по Bluetooth, двухмерная мо-
дель робота и т. д.
Инструментальная поддержка программирования роботов в
QReal:Robots состоит из двух частей: интерпретатор диаграмм и
генератор кода на языке C для загрузки программы на робот. Ин-
терпретатор создавался с учётом следующих требований.
• Возможность быстро задавать поведение для новых блоков
визуального языка.
• Интерпретация диаграмм передачей роботу команд по Bluetooth
или USB, в зависимости от выбора пользователя.
• Наличие двухмерной модели робота, которая могла бы интер-
претировать диаграмму вместо реального робота. Двухмер-
ная модель робота должна взаимодействовать с симулируе-
мым окружением— должна быть возможно нарисовать сте-
ны, линии и цветные области на полу.
• Архитектура должна позволять быстро поддержать новые ви-
ды оборудования, например, нестандартные сенсоры.
Архитектура интерпретатора приведена на рис. .
Процесс интерпретации диаграммы начинает класс Interpreter,
который хранит в себе контекст вычислений и контролирует пото-
ки запущенной программы. Первое, что он делает—обходит пере-
данную на интерпретацию диаграмму, создавая для каждого бло-
ка объект, обеспечивающий его выполнение. При этом заполняет-
ся таблица блоков BlocksTable, ставящая в соответствие каждо-
му идентификатору элемента на диаграмме такой объект, чтобы в
дальнейшем иметь возможность быстро найти объект-исполнитель
для передачи управления. После этого создаётся основной поток
программы, содержащий в себе маркер исполнения. Маркер уста-
навливается на блок начала или инициализации, после чего про-
водится инициализация логической модели робота (класс Robot-
Model, в зависимости от настроек, может реализовывать как управ-
ление реальным роботом, так и управление двухмерной моделью,
для этого используется шаблон «стратегия»). После того как ини-
циализация закончена (для этого может потребоваться дождаться
ответа от робота об инициализации оборудования), запускается ме-
тод interpret() блока, который хранит маркер выполнения. Блок вы-
полняется (для этого снова может потребоваться асинхронная по-
сылка команд на робота и ожидание ответа) и после этого сообщает
своему потоку, на какой следующий блок нужно передать маркер
управления. Так продолжается до тех пор, пока маркер управления
потока не доходит до блока «Конец», и после этого поток заверша-
ется.
Взаимодействие с реальным роботом осуществляется через реа-
лизацию интерфейса RobotCommunicationInterface, который предо-
ставляет возможность послать роботу заданный пакет байтов. Ро-
боты Lego Mindstorms NXT позволяют управлять собой с помо-
щью команд по Bluetooth и по USB, поэтому в QReal:Robots име-
ются две реализации RobotCommunicationInterface. Управление по
Bluetooth осуществляется через виртуальный COM-порт Bluetooth-
соединения, обеспечиваемый средствами операционной системы, а
управление по USB требует наличия установленного драйвера ро-
бота, и команды посылаются роботу через этот драйвер. Каждый
блок диаграммы реализован в терминах логической модели робо-
та, логическая модель в случае взаимодействия с реальным робо-
том формирует управляющую команду и посылает её роботу через
RobotCommunicationInterface. В случае с двухмерной моделью ло-
гическая модель вызывает методы классов, реализующих двухмер-
ную модель, которые отрабатывают команды и формируют значе-
ния сенсоров.
Двухмерная модель моделирует робота с жёстко заданным рас-
положением моторов, однако позволяет настраивать расположе-
ние сенсоров. Поддерживаются сенсоры касания, расстояния, цве-
та. Двухмерная модель позволяет рисовать стены, линии и цветные
области на полу. Внешний вид окна двухмерной модели представ-
лен на рис. .
Генератор кода на C в QReal:Robots реализован в виде отдель-
ной компоненты, которая может подключаться к основной про-
грамме независимо от интерпретатора. В качестве среды времени
исполнения (runtime) генератор использует операционную систему
nxtOSEK [28], одну из самых быстрых доступных на данный мо-
мент операционных систем для роботов Lego. Генератор порожда-
ет c-файл с кодом решения задачи и oil-файл с настройками пара-
метров выполнения кода. Далее автоматически запускается крос-
скомпилятор из состава nxtOSEK, собирающий эти файлы вместе с
заголовочными файлами операционной системы, после чего полу-
чившийся бинарный образ передаётся роботу по USB посредством
утилиты, распространяемой с драйвером робота. Для пользовате-
ля этот процесс прозрачен, достаточно подключить робот, нажать
кнопку «Загрузить программу на робот», и после этого сгенериро-
ванный по диаграмме код программы покажется в окне встроенно-
го в QReal текстового редактора, и одновременно начнётся процесс
компиляции и загрузки программы.
6. Опыт применения QReal
6.1. Создание графического редактора
Визуальный язык для QReal:Robots создавался с помощью мета-
редактора QReal. Полная метамодель одной из версий языка пред-
ставлена на рис. . Как видно, она целиком помещается на одном
экране. Все элементы также имеют свойства (в том числе, внеш-
ний вид), которые на рисунке не показаны.
Корневой сущностью метамодели является диаграмма, на неё
помещаются все элементы языка. Диаграмма—это вкладка в па-
литре блоков созданного языка, на неё добавляются все блоки
языка, все виды связей, все перечислимые типы, используемые в
свойствах элементов, и т. д. Одна метамодель может содержать
несколько диаграмм, тогда плагин-редактор, сгенерированный из
этой метамодели, при загрузке будет добавлять несколько вкла-
док в палитру. Внутри диаграммы находятся узлы—элементы ви-
зуального языка. Узлы могут быть связаны отношением наследо-
вания и отношением «содержит». Последнее указывает, что один
узел может содержать в себе другой, т. е. являться контейнером
для этого узла. В языке программирования роботов узел «диа-
грамма» связан отношением «содержит» с узлом AbstractNode—
узлом-предком всех узлов языка, таким образом, диаграмма мо-
жет содержать все элементы. Больше, в силу простоты языка, от-
ношение «содержит» в метамодели не используется. Отношение
наследования в метамодели можно понимать как обычное насле-
дование в объектно-ориентированных языках программирования—
узел-потомок может использоваться везде, где может использовать-
ся узел-предок, и наследует все его свойства. В метамодели языка
программирования роботов наследование оказалось довольно удоб-
ным инструментом: узел Диаграмма наследуется от импортирован-
ного из другой метамодели узла Диаграмма, все другие узлы насле-
дуются от узла AbstractNode. Заметим, что AbstractNode на одной
диаграмме представлен дважды— это два образа одного и того же
логического элемента модели. Это иллюстрирует важную особен-
ность QReal—разделение логической и графической моделей си-
стемы. Генераторы и другие инструменты работают с логической
моделью, пользователь может редактировать графическую модель,
которая связана с логической, но может отличаться. Например,
один и тот же элемент может отображаться на нескольких раз-
ных диаграммах или даже в нескольких местах одной диаграммы,
это позволяет рисовать диаграммы, представляющие одни и те же
сущности с разных точек зрения. В метамодели языка программи-
рования роботов второй образ AbstractNode использован для удоб-
ства отображения, чтобы уменьшить количество пересекающихся
линий.
От AbstractNode наследуются абстрактные узлы команд мото-
ров (EngineCommand) и сенсоров (SensorBlock). Абстрактные уз-
лы не отображаются в палитре, поскольку для них не задаётся
графическое представление, однако туда вынесены общие свойства
узлов-наследников. От EngineCommand наследуется один конкрет-
ный блок (EngineStop, остановка мотора) и один абстрактный (EngineMovementCommand,
команда движения). От EngineMovement
Command наследуются два конкретных блока «моторы вперёд» и
«моторы назад», которые своих свойств не имеют, и их семантика
определяется помимо свойств узла-родителя их типом.
Свойства внутри узла имеют имя, тип и значение по умолча-
нию. Тип свойства определяет, какие допустимые значения может
принимать свойство и как будет осуществляться редактирование
значений в редакторе свойств. Например, для строкового свойства
в редакторе свойств будет показано поле ввода, для булевого свой-
ства—флажок, для перечислимого типа—выпадающий список с
возможными значениями. Перечислимые типы определяются в ме-
тамодели языка, например, в метамодели языка роботов, определён
тип-перечисление SensorPort, принимающий значения 1, 2, 3, 4 и ис-
пользуемый как тип свойств, определяющих порты сенсоров. Кро-
ме типов-перечислений, в метамодели задаются виды связей, для
которых указывается, как именно их следует рисовать (заполнен-
ные или пустые стрелки, ромбы и т. д. на каждом из концов связи,
пунктирная или сплошная линия, и т. д.), свойства, к каким узлам
связь их можно присоединять.
После того, как метамодель нарисована, с помощью редакто-
ра форм фигур задаются изображения для элементов. После этого
можно сгенерировать редактор. Вообще, получить из метамодели
редактор визуального языка в QReal можно тремя способами.
Первый способ применяется наиболее часто и предполагает ис-
пользование промежуточного xml-формата представления метамо-
дели. Пока метаредактора в QReal не существовало, все метамодели
задавались вручную в xml-файлах, по которым затем порождал-
ся код на C++, компилировался и подключался к основной части
системы как динамически загружаемая библиотека. С появлени-
ем метаредактора в эту схему добавился генератор, порождающий
по метамодели, хранящейся в репозитории, xml-файл с описанием
метамодели.
Второй способ был реализован позже и предполагает генерацию
кода на C++ непосредственно по метамодели, без порождения про-
межуточного представления. Такой способ проще, но менее устой-
чив к изменениям в метаязыке— если удалить какой-либо элемент
метаязыка или даже какое-либо его свойство, старые метамодели,
содержащие удалённый элемент, невозможно будет загрузить и от-
редактировать. В xml-файлы в таких ситуациях изменения неслож-
но внести вручную, редактировать вручную файлы с сохранёнными
метамоделями гораздо сложнее. Поэтому второй способ не исполь-
зуется в процессе сборки QReal, а существует как альтернативный
до тех пор, пока не будет создано надёжного средства поддержки
эволюции языков. На данный момент в процессе сборки QReal все
плагины-редакторы (включая метаредактор) собираются из xml-
файлов с метамоделями.
Третий способ предполагает не генерацию по метамодели ко-
да, реализующего редактор, а непосредственную интерпретацию
метамодели в интерпретаторе, эмулирующем функциональность
плагина-редактора. Такой способ технически наиболее удобен, по-
скольку для создания редактора не будет требоваться компилятор
C++ и не требуется порождение никаких промежуточных пред-
ставлений, однако интерпретируемый редактор работает медленнее
сгенерированного. Интерпретатор может обладать рядом возмож-
ностей, недоступных сгенерированным редакторам, таким как мо-
дификация визуального языка «на лету», но на данный момент эти
возможности в QReal не реализованы.
Среда QReal также имеет средства поддержки написания ге-
нераторов, оформленные в виде библиотеки классов. Генераторы
реализуются по шаблонной схеме, довольно типичной для генера-
торов кода по диаграммам в DSM-подходе [19]. Имеется шаблон
порождаемого исходного кода, представляющий собой почти гото-
вую программу со специально размеченными местами, куда надо
вставить код, сгенерированный по диаграмме. При генерации ко-
да могут использоваться вспомогательные шаблоны—как правило,
небольшие фрагменты программы, параметризуемые информацией
из диаграммы. Небольшой пример шаблона приведён ниже:
\begin{verbatim}
void ecrobot_device_initialize(void)
{
@@INITHOOKS@@
}
Здесь на место @@INITHOOKS@@ вставляется код, сгенерированный
по блоку инициализации диаграммы, а всё остальное попадает в
выходной файл без изменений. По каждому блоку генерируется
свой небольшой фрагмент программы, при этом некоторую слож-
ность представляют структурные операторы, например, циклы или
условные переходы. Проблема в том, что диаграмма может быть на-
рисована неструктурно, синтаксис визуального языка не запрещает
этого—например, условный переход внутрь цикла или условный
переход наружу из оператора if. С точки зрения визуального язы-
ка такие ситуации абсолютно корректны, но в текcтовое представ-
ление они переводятся только с использованием операторов goto
(или техник goto elimination, известных в реинжиниринге). Одна-
ко поскольку сгенерированный код предполагается использовать в
иллюстративных целях, применять оператор goto было бы крайне
нежелательно. Генератор использует набор эвристик, позволяющих
найти на диаграмме фрагменты, соответствующие структурным
операторам if, циклам while и do/while. В случае, если генератор
не может породить структурный код по данной диаграмме, выда-
ётся ошибка и код не порождается вообще. Интерпретация такой
диаграммы, тем не менее, вполне возможна.
6.2. Обсуждение
Среду QReal:Robots вряд ли удалось бы разработать в столь корот-
кие сроки « вручную». Использование metaCASE-системы QReal
позволило существенно упростить создание визуального языка и
соответствующего редактора диаграмм. Прототип языка был го-
тов за несколько часов, так что уже после недели разработки пер-
вый функциональный прототип среды программирования, вклю-
чающий в себя редактор диаграмм и интерпретатор, управляющий
роботом по Bluetooth, был представлен специалистам по киберне-
тике. При создании языка наиболее затратным по времени оказался
поиск подходящих иконок для блоков диаграммы. Создание мета-
модели языка с помощью метаредактора оказалось довольно быст-
рым, первая версия языка содержала порядка десяти блоков, нахо-
дящихся другс другом в несложных отношениях, и с тех пор язык
лишь незначительно вырос, вся его метамодель в графическом ви-
де помещается на один экран. Поскольку редактор диаграмм языка
по метамодели генерируется автоматически, была возможность не
только сэкономить время на разработке редактора, но и экспери-
ментировать с языком, меняя блоки, их свойства и внешний вид.
Кроме того, простота визуального представления синтаксиса языка
дала возможность легко расширять и изменять его в дальнейшем,
причём не только исходным авторам языка. Впоследствии разра-
ботка QReal:Robots была во многом передана студентам, которые
без особых сложностей редактировали и расширяли язык по ме-
ре необходимости. Рассматривалась даже возможность позволить
самим пользователям менять язык, например, дать возможность
учителям информатики настраивать язык для конкретного заня-
тия, но это не было реализовано в силу недоработки средств мета-
моделирования в QReal.
Если синтаксис языка оказался хорошо формализуемым и про-
цесс построения редактора языка по описанию синтаксиса удалось
автоматизировать, то с семантикой ситуация оказалась хуже. Си-
стема QReal на момент разработки QReal:Robots не имела никаких
средств описания семантики языка, так что вся инструментальная
поддержка, включая интерпретатор диаграмм и генератор кода для
заливки на робот, реализовывалась вручную на C++. Эта задача
трудоёмка и сама по себе— требовалось изучить систему прямых
команд робота для управления им с компьютера, изучить API опе-
рационной системы робота для генерации кода для неё, наладить
работу с Bluetooth, USB, кросскомпиляцию, прошивку робота, за-
грузку программы на робота и прочие проблемы, не автоматизиру-
емые в принципе. Однако некоторый код получился довольно шаб-
лонным—каждому блоку соответствовал некоторый класс на С++,
реализовывавший его функциональность при интерпретации, и по
крайней мере шаблоны для таких классов можно было бы генери-
ровать автоматически по описанию языка. Интерпретатор в целом
также мало связан конкретно с языком программирования робо-
тов, так что часть его можно было бы генерировать по описанию
семантики языка, представленной в каком-то виде, а часть вынести
в библиотеку и использовать в сгенерированном коде. Предполага-
ется, что использование интерпретируемых языков программиро-
вания для описания части поведения интерпретатора позволило бы
ускорить разработку, но эта идея ещё не была проверена.
Генератор кода представляется наиболее интересной целью для
автоматизации, поскольку содержит много похожего от блока к
блоку кода. Как и интерпретатор, генератор содержит неспецифич-
ные для языка программирования роботов части, которые были бы
применимы для всех визуальных языков с семантикой, похожей на
семантику диаграмм активностей UML или блок-схем. Над авто-
матизацией создания генератора в QReal в данный момент ведёт-
ся работа, был создан язык описания правил генерации, берущий
на себя многие типичные задачи, такие как обход графа модели
и вывод текста. Тем не менее, такой язык не позволяет выполнять
сложные алгоритмические действия, например, goto elimination или
поиск переменных в математических выражениях для дальнейшей
автоматической генерации блока объявления переменных.
Таким образом, результатом эксперимента по разработке систе-
мы визуального программирования с помощью metaCASE-системы
стало то, что с помощью такого подхода можно создать систему, ко-
торая была бы не хуже разработанных вручную, и при этом время
на разработку визуального редактора с помощью метамоделиро-
вания можно сократить в несколько десятков раз по сравнению с
разработкой редактора вручную. Однако выигрыш при разработке
и доведении до внедрения системы в целом оказался не таким зна-
чительным, как при разработке только редактора, потому как мно-
гие задачи принципиально неавтоматизируемы. В процессе экспе-
римента были выявлены типичные при разработке подобного рода
систем задачи, которые можно в некоторой степени автоматизиро-
вать в metaCASE-системе, но их автоматизация требует дополни-
тельных исследований. Большая часть таких задач требует изуче-
ния способов задания семантики визуальных языков. Однако даже
сейчас DSM-подход показал себя полезным на практике, и дальней-
шие исследования в этом направлении смогут помочь эффективно
создавать специализированные языки и среды программирования
даже для гораздо более узких предметных областей и задач.
Заключение
В результате применения описанного в статье подхода удалось
разработать полноценную среду программирования роботов, кото-
рую оказалось возможным предложить школьникам и учителям
в качестве замены используемых в школах средств. QReal:Robots
была представлена на «Открытых состязаниях Санкт-Петербурга
по робототехнике» и на робототехническом фестивале «Робофест
2012» в Москве. В качестве доказательства применимости сре-
ды QReal:Robots к реальным задачам, решаемым школьниками,
команда студентов приняла участие в соревнованиях в движе-
нии робота по линии с программой, реализованной целиком на
QReal:Robots. Несмотря на то, что для студентов участие в со-
ревнованиях стало практически первым опытом решения задач ро-
бототехники, им удалось показать довольно неплохие результаты,
заняв места в середине таблицы, несмотря на то, что довольно мно-
гие участники использовали специально созданные для этой задачи
роботы. QReal:Robots представлялся также в виде стендовых до-
кладов, где вызвал большую заинтересованность у потенциальных
пользователей.
Эксперимент показал применимость DSM-подхода для разра-
ботки системы, которая может распространяться как отчуждаемый
продукт и рассчитана на аудиторию, не владеющую программиро-
ванием. При этом использование средств автоматизации создания
графических редакторов сэкономило много времени и усилий.